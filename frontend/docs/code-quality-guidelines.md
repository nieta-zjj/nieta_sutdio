# 前端代码质量指南

本文档详细说明了前端仓库的代码要求、质量标准、检测方式以及最佳实践。所有开发者应遵循这些指南，以确保代码的一致性、可维护性和高质量。

**重要说明：本项目的代码审核体系仅进行检查，不会自动修复任何问题。所有修复都必须由开发者手动完成。**

## 目录

1. [代码质量要求](#代码质量要求)
2. [代码风格规范](#代码风格规范)
3. [代码检查工具](#代码检查工具)
4. [安全规范](#安全规范)
5. [性能优化指南](#性能优化指南)
6. [手动修复指南](#手动修复指南)
7. [提交前检查清单](#提交前检查清单)

## 代码质量要求

### 1. 代码复杂度控制

- **认知复杂度限制**：函数的认知复杂度不应超过15（由SonarJS插件检测）
- **函数长度**：单个函数不应过长，建议不超过50行
- **组件拆分**：复杂组件应拆分为多个小型组件，每个组件职责单一
- **嵌套层级**：控制条件语句和循环的嵌套层级，不应超过3层
- **重复代码**：避免重复字符串（超过5次重复会被检测）
- **相同函数**：避免完全相同的函数实现

### 2. 类型安全

- **使用TypeScript**：所有代码应使用TypeScript编写，确保类型安全
- **避免any**：尽量避免使用`any`类型，应定义明确的接口和类型
- **类型导出**：公共类型应在`types`目录下定义并导出
- **类型检查**：提交前应通过TypeScript类型检查（`pnpm type-check`）

### 3. 错误处理

- **异步错误**：所有异步操作应有适当的错误处理
- **边界检查**：对用户输入和外部数据进行适当的边界检查
- **日志记录**：关键操作应有适当的日志记录，便于调试

### 4. 代码重用

- **避免重复**：避免代码重复，提取共用逻辑到独立函数或组件
- **使用钩子**：使用自定义钩子（Custom Hooks）组织相关状态和逻辑
- **组件抽象**：将通用UI模式抽象为可重用组件
- **工具函数**：将通用功能抽象为工具函数，放在`utils`目录下

## 代码风格规范

### 1. 格式化规则

- **使用Prettier**：所有代码应使用Prettier格式化，确保一致的代码风格
- **缩进**：使用2个空格缩进
- **行宽**：最大行宽为100个字符
- **引号**：使用双引号（`"`）而非单引号
- **分号**：语句末尾使用分号
- **尾随逗号**：对象和数组使用尾随逗号（ES5兼容）
- **括号间距**：对象字面量中的括号内部有空格
- **箭头函数参数**：箭头函数参数始终使用括号

### 2. 命名规范

- **组件命名**：使用PascalCase命名组件（如`UserProfile`）
- **文件命名**：组件文件使用PascalCase（如`UserProfile.tsx`），非组件文件使用camelCase（如`apiClient.ts`）
- **钩子命名**：自定义钩子以`use`前缀命名（如`useAuth`）
- **常量命名**：全局常量使用UPPER_SNAKE_CASE（如`API_BASE_URL`）
- **变量命名**：使用有意义的描述性名称，避免缩写
- **布尔值命名**：布尔值变量应使用`is`、`has`、`should`等前缀（如`isLoading`）
- **事件处理函数**：使用`handle`前缀（如`handleSubmit`）

### 3. 导入顺序

按以下顺序组织导入语句：

1. 类型导入
2. 内置模块
3. 外部库
4. 内部模块（以`~/`开头）
5. 父目录模块
6. 同级目录模块
7. 索引模块

导入组之间应有空行分隔。

### 4. 代码注释

- **文档注释**：公共API、组件和函数应有JSDoc风格的文档注释
- **复杂逻辑**：复杂逻辑应有注释说明
- **TODO注释**：使用`// TODO:`标记待完成的工作
- **废弃标记**：使用`@deprecated`标记废弃的API

## 代码检查工具

### 1. ESLint

- **配置文件**：`eslint.config.mjs`
- **主要插件**：

  - `sonarjs`：检测代码中的潜在问题和复杂度
  - `security`：安全漏洞检测
  - `react`：React特定规则
  - `react-hooks`：React Hooks规则
  - `jsx-a11y`：可访问性规则
  - `@typescript-eslint`：TypeScript特定规则
  - `import`：导入顺序规则
  - `unused-imports`：未使用导入检测
  - `prettier`：与Prettier集成

- **运行命令**：
  - `pnpm lint:check`：仅检查代码问题，不自动修复
  - `pnpm lint:strict`：严格模式运行ESLint（不允许警告）
  - `pnpm check:eslint`：仅运行ESLint检查

### 2. Prettier

- **配置文件**：`.prettierrc`
- **主要配置**：

  - `semi: true`：使用分号
  - `singleQuote: false`：使用双引号
  - `tabWidth: 2`：2空格缩进
  - `printWidth: 100`：最大行宽100
  - `trailingComma: "es5"`：ES5兼容的尾随逗号

- **运行命令**：
  - `pnpm format:check`：仅检查格式问题，不自动修复
  - `pnpm format:write`：格式化所有文件（手动修复）

### 3. TypeScript

- **配置文件**：`tsconfig.json`
- **主要配置**：

  - `strict: true`：启用严格模式
  - `noEmit: true`：不生成输出文件
  - `skipLibCheck: true`：跳过库文件检查
  - `isolatedModules: true`：每个文件作为单独的模块

- **运行命令**：
  - `pnpm type-check`：运行TypeScript类型检查

### 4. 依赖检查

- **工具**：`npm-check`
- **检查内容**：

  - 未使用的依赖
  - 缺失的依赖
  - 可更新的依赖

- **运行命令**：
  - `pnpm check:deps`：运行依赖检查

### 5. 综合质量检查

- **工具**：自定义脚本`scripts/code-quality.js`
- **特点**：仅检查不修复，所有问题需要手动处理

- **运行命令**：
  - `pnpm check`：运行所有质量检查
  - `pnpm check:eslint`：仅运行ESLint检查
  - `pnpm check:types`：仅运行TypeScript检查
  - `pnpm check:format`：仅运行格式检查
  - `pnpm check:deps`：仅运行依赖检查

### 6. 代码质量报告

- **工具**：自定义脚本`scripts/generate-report.js`
- **报告类型**：

  - ESLint报告（JSON + HTML格式）
  - Prettier格式检查报告
  - 代码复杂度报告
  - 依赖分析报告

- **运行命令**：
  - `pnpm report`：生成所有报告
  - `pnpm report:eslint`：仅生成ESLint报告
  - `pnpm report:format`：仅生成格式检查报告
  - `pnpm report:complexity`：仅生成代码复杂度报告
  - `pnpm report:deps`：仅生成依赖分析报告

## 安全规范

### 1. 安全检查规则

- **对象注入检测**：避免动态对象属性访问
- **正则表达式安全**：避免非字面量正则表达式
- **不安全正则**：检测可能导致ReDoS的正则表达式
- **缓冲区安全**：避免不安全的缓冲区操作
- **子进程安全**：谨慎使用子进程
- **模板转义**：确保模板引擎正确转义
- **表达式求值**：避免使用eval相关函数
- **文件系统安全**：避免非字面量文件名
- **模块加载安全**：避免动态require
- **时序攻击**：避免可能的时序攻击
- **随机数安全**：使用安全的随机数生成

### 2. 安全最佳实践

- **输入验证**：对所有用户输入进行验证和清理
- **输出编码**：对输出到HTML的内容进行适当编码
- **HTTPS使用**：在生产环境中始终使用HTTPS
- **敏感信息**：不在代码中硬编码敏感信息
- **依赖安全**：定期检查和更新依赖项的安全漏洞

## 性能优化指南

### 1. 渲染优化

- **避免不必要的渲染**：使用`React.memo`、`useMemo`和`useCallback`
- **虚拟列表**：对长列表使用虚拟化技术
- **懒加载**：使用`React.lazy`和`Suspense`懒加载组件
- **代码分割**：使用动态导入进行代码分割

### 2. 数据获取

- **缓存**：对频繁请求的数据进行缓存
- **预取**：在用户可能需要数据前预先获取
- **分页**：对大量数据使用分页加载
- **防抖和节流**：对用户输入相关的请求使用防抖和节流

### 3. 资源优化

- **图片优化**：使用Next.js的`Image`组件优化图片
- **字体优化**：使用`next/font`优化字体加载
- **CSS优化**：使用Tailwind CSS减少CSS体积
- **Tree Shaking**：确保未使用的代码被移除

## 手动修复指南

### 1. ESLint问题修复

#### 认知复杂度过高

- **问题**：函数认知复杂度超过15
- **修复方法**：
  1. 将复杂函数拆分为多个小函数
  2. 提取重复逻辑到独立函数
  3. 简化条件判断逻辑
  4. 使用早期返回减少嵌套

#### React Hooks依赖警告

- **问题**：useEffect、useMemo等Hook的依赖数组不完整
- **修复方法**：
  1. 添加缺失的依赖到依赖数组
  2. 使用`useCallback`包装函数依赖
  3. 使用`useMemo`包装对象依赖
  4. 如果确实不需要依赖，添加ESLint忽略注释并说明原因

#### 未使用变量/导入

- **问题**：存在未使用的变量或导入
- **修复方法**：
  1. 删除未使用的变量和导入
  2. 如果变量有意忽略，使用下划线前缀（`_variable`）
  3. 如果是函数参数，使用下划线前缀或省略参数名

#### 安全问题

- **问题**：检测到潜在的安全漏洞
- **修复方法**：
  1. 对象注入：使用`Object.prototype.hasOwnProperty.call()`或`Map`
  2. 正则表达式：使用字面量正则表达式
  3. 文件操作：验证文件路径，使用白名单
  4. 用户输入：进行适当的验证和清理

### 2. TypeScript问题修复

#### 类型不兼容

- **问题**：类型赋值不兼容
- **修复方法**：
  1. 定义明确的接口和类型
  2. 使用类型断言（谨慎使用）
  3. 修改代码以符合类型要求
  4. 使用联合类型或泛型

#### 对象可能为undefined

- **问题**：访问可能为undefined的对象属性
- **修复方法**：
  1. 使用可选链操作符（`?.`）
  2. 使用空值合并操作符（`??`）
  3. 添加类型守卫
  4. 提供默认值

### 3. Prettier格式问题修复

#### 格式不一致

- **问题**：代码格式不符合Prettier规则
- **修复方法**：
  1. 运行`pnpm format:write`自动修复
  2. 配置IDE自动格式化
  3. 检查`.prettierrc`配置是否正确

### 4. 依赖问题修复

#### 未使用的依赖

- **问题**：package.json中存在未使用的依赖
- **修复方法**：
  1. 确认依赖确实未使用
  2. 使用`pnpm remove <package-name>`移除
  3. 检查是否为开发时依赖

#### 缺失的依赖

- **问题**：代码中使用了未在package.json中声明的依赖
- **修复方法**：
  1. 使用`pnpm add <package-name>`添加依赖
  2. 确认是否应该是开发依赖（`pnpm add -D <package-name>`）

#### 过时的依赖

- **问题**：依赖版本过旧
- **修复方法**：
  1. 检查更新日志确认兼容性
  2. 使用`pnpm update <package-name>`更新
  3. 测试更新后的功能

## 提交前检查清单

在提交代码前，请确保：

### 1. 代码质量检查

- [ ] **ESLint检查**：运行`pnpm check:eslint`确保无ESLint错误
- [ ] **TypeScript检查**：运行`pnpm type-check`确保无类型错误
- [ ] **格式检查**：运行`pnpm format:check`确保格式正确
- [ ] **依赖检查**：运行`pnpm check:deps`检查依赖问题
- [ ] **全面检查**：运行`pnpm check`执行全面代码质量检查

### 2. 功能测试

- [ ] **手动测试**：确保功能正常工作，无明显bug
- [ ] **边界测试**：测试边界情况和错误处理
- [ ] **性能测试**：确保没有明显的性能问题

### 3. 代码审查

- [ ] **自我审查**：仔细检查自己的代码变更
- [ ] **同事审查**：如果可能，请同事审查你的代码
- [ ] **文档更新**：如果需要，更新相关文档

### 4. 安全检查

- [ ] **敏感信息**：确保没有提交敏感信息（密码、密钥等）
- [ ] **安全规则**：确保通过所有安全检查规则
- [ ] **依赖安全**：确保没有已知的安全漏洞

### 5. 最终确认

- [ ] **构建测试**：运行`pnpm build`确保能正常构建
- [ ] **提交信息**：编写清晰的提交信息
- [ ] **分支整理**：确保分支历史清晰

## 常见问题与解决方案

### 1. 为什么不自动修复？

本项目采用仅检查不自动修复的策略，原因如下：

- **代码质量**：自动修复可能掩盖真正的代码问题
- **学习效果**：手动修复有助于开发者理解和学习最佳实践
- **代码控制**：开发者对每一行代码变更都有完全的控制权
- **避免意外**：防止自动修复引入意外的问题

### 2. 如何处理大量问题？

当面对大量代码质量问题时：

1. **优先级排序**：先修复错误，再修复警告
2. **分批处理**：将问题分批次处理，避免一次性修改过多
3. **模式识别**：识别重复的问题模式，批量修复
4. **工具辅助**：使用IDE的查找替换功能辅助修复

### 3. 如何保持代码质量？

- **定期检查**：定期运行代码质量检查
- **持续学习**：学习和应用最佳实践
- **团队协作**：与团队成员分享经验和知识
- **工具配置**：配置IDE和编辑器支持实时检查

---

本文档将随项目发展不断更新。如有疑问或建议，请联系项目维护者。
